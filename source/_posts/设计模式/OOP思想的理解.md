---
title: 面向对象设计思想的理解
date: 2022-03-26 13:23:14
tags: OOP设计思想
categories: OOP设计思想
---

> 我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协定的参与者，这个协定以语言的形式固定下来......除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈。
——Benjamin Lee Whorf(1897—1941)

计算机是不同类型的表达媒体。它更像大脑的一部分，以及一种如写作、绘画、雕刻、动画、电影等一样的表达形式。绘画在图纸上绘制出所要描述、抽象和表达的各个对象，而**计算机通过抽象出不同的类对象对现实事物进行表达**。

所以，计算机其实更像是：

1. 会思考的机器：“头脑的自行车”；
2. 一种表达形式：如同绘画、雕刻、动画、电影、写作，只是表达的方式和呈现的形式有区别。总归**都是对现实对象的抽象和描述表达**。

**“我想告诉计算机关于这个世界的是….bla bla bla”，然后尽可能地让计算机更加简单准确地建立起对世界的认知，最后计算机基于它的“认知”，来帮助你解决问题。**

OOP思想的挑战在于：

1. 如何用计算机语言对现实世界进行更好的抽象与表达；
2. 在现实的问题空间的元素和解空间的对象之间如何创建一对一的映射。当我们想在现实生活中遇到一类问题，然后我们希望通过计算机来求解该问题，那么最难的地方在于应该如何将现实中的问题或系统（问题空间）抽象后用计算机语言表达出来（**程序员充当问题空间与解空间的翻译官**），然后模拟问题并在计算机中（解空间）解决该问题。

## 一、抽象思维与表达

[如何提高抽象能力](https://www.zhihu.com/question/19895931) 

人们所能解决的问题的复杂性直接取决于抽象的类型和质量。抽象的类型和质量决定了计算机的表达能力。抽象的类型和质量越高，意味着计算机的表达能力越强，对问题的表达越透彻和准确。而计算机对问题的思维与表达越好，意味着解空间的模型建立的越优秀，对问题空间的求解就会效率越高越优雅。因此，抽象是一种思维能力，也是一种表达能力。

FORTRAN/BASIC/C语言等是对汇编语言的抽象，它们所作的主要抽象仍要求在解决问题时要基于计算机的结构，也就是与硬件关联性大，也就是低级别抽象；Java OOP在解决问题时是基于所要解决的问题的结构来考虑的，与硬件无关，也就是高级抽象。

几个关键的理解点：

1. 所谓的“类型”是指“所抽象的是什么？”
2. “问题空间”与“解空间”；“问题空间中的元素”与“解空间中的表示”。
3. 对象：我们将问题空间中的元素及其在解空间中的表示称为“对象”。

因此，当你在阅读描述解决方案的代码的同时，也是在阅读**问题的表述**。所以，OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。**因此，阅读源码时，首先应该把握整体，也就是搞清楚别人是怎么构建抽象来表达描述问题的？搞清楚这个问题后，再抓细节，去看具体代码是如何实现的？**

**面向对象程序设计的挑战之一，就是在问题空间的元素和解空间的对象之间将创建一对一的映射。**

1. 一种类型是可以根据具体的名字、概念得来：比如狗、银行、柜员等；或是依据事物的共性进行抽象。
2. 还有一种类的是作为辅助、控制、逻辑、关联、协调类等存在：比如Util工具类、Controller控制中心、某个服务类；这是对管理、控制、辅助、协调作用等的抽象，好比对大脑思维的提取，所以它可能不会具体映射到现实的某个名字或实际存在的概念或物体，这些类型的对象是要到解空间才会真正构建出来，在问题空间是不会存在的。

## 二、类型与对象

### 2.1. 对象

对象：我们将问题空间中的元素及其在解空间中的表示称为“对象”。每个对象看起来都有点像一台微型计算机——它具有状态，具有操作，用户可以要求它执行这些操作。不同对象组件再相互配合，完成更大型的工作。

OOP五大特性Alan Kay：

1. 万物皆为对象：理论上讲，你可以**抽取待求问题的任何概念化构件(狗、建筑物、服务等)，将其表示为程序中的对象**。当然，有些是**实际具体的对象（可能是物理存在的如汽车，可能是概念存在的如股票）**，比如狗；而有些是**逻辑对象**，比如某个工具类对象、辅助类对象，它们是在解空间产生的对象。
2. 程序是对象的集合，它们通过发送消息来告知彼此要做的：要想请求一个对象，就必须通过该对象发送一条消息给他。可以**把消息想象为对某个特定对象的方法的调用请求**。比如str.split就是向str对象发送分割字符串消息的请求。
3. 每个对象都有自己的由其他对象所构成的存储：可以通过创建包含现有对象的包的方式来创建新类型的对象，也就是组合。因此，可以在程序中构建复杂的体系和对象关系，同时将其复杂性隐藏在对象的简单性背后。（**对象嵌套**）
4. 每个对象都拥有其类型：每个对象都是某个类型的一个实例。每个类型最重要的区别于其他类的特性就是“可以发送什么样的消息给它（接口方法的区别）”。
5. 某一特定类型的所有对象都可以接收同样的消息（具有一组相同的接口）：比如“圆形”类型的对象同时也是“几何形”类型的对象，因此它必定能够接受发送给“几何形”对象的消息。

Booch对对象提出了一个更加简洁的描述：对象具有状态、行为和标志。这意味着每一个对象都可以拥有内部数据(它们给出了该对象的状态)和方法(它们产生行为)，并且每一个对象都可以唯一地与其他对象区分开来，具体说来，就是每一个对象在内存中都有一个唯一的地址。

### 2.2. 类型与对象

所有的对象都是唯一的，但同时也是具有相同的特性和行为的对象所归属的类的一部分。类描述了具有相同特性(数据元素)和行为(功能)的对象集合，所以一个类实际上就是一个数据类型。

1. 任何程序都是你所设计的系统的一种仿真。
2. 接口确定了对某一特定对象所能发出的请求的集合。每一个可能的请求都有一个方法与之相关联，当向对象发送请求时，与之相关联的方法就会被调用。

### 2.3. 对象与服务提供者

开发或理解一个程序设计时的最好方法之一就是：**将对象想象为“服务提供者”**。程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这一目的。你的目标是：“去创建(或者最好是在现有代码库中寻找)能够提供理想的服务来**解决问题的一系列对象**。”

将对象看作是服务提供者还有一个附带好处：它有助于提高对象的内聚性。高内聚是软件设计的基本质量要求之一：这意味着一个软件构件(例如一个对象，当然它也有可能是指一个方法或一个对象库)的各个方面“组合”得很好。_人们在设计对象时所面临的一个问题是：将过多的功能都塞在一个对象中。_

例如，在检查打印模式的模块中，你可以这样设计一个对象，让它了解所有的格式和打印技术。你可能会发现，这些功能对于一个对象来说太多了，你需要的是三个甚至多个对象，其中，一个对象可以是所有可能的支票排版的目录，它可以被用来查询有关如何打印一张支票的信息；另一个对象或对象集合可以是一个通用的打印接口，它知道有关所有不同类型的打印机的信息(但是不包含任何有关簿记的内容，它更应该是一个需要购买而不是自己编写的对象)；第三个对象通过调用另外两个对象的服务来完成打印任务。这样，每个对象都有一个它所能提供服务的内聚的集合。

在良好的面向对象设计中，每个对象都可以很好地完成一项任务，但是它并**不试图做更多的事**。将对象作为服务提供者看待是一件伟大的简化工具，这不仅在设计过程中非常有用，而且当其他人试图理解你的代码或重用某个对象时，如果他们看出了这个对象所能提供的服务的价值，它会使调整对象以适应其设计的过程变得简单得多。

## 三、现实问题的分解与解空间的抽象表达

> 将问题分解为对象集合的一种合理实践方式。

面对问题时，我们的**思考该如何开始**呢？先问自己一个问题：“如果我可以将问题从表象中抽取出来，那么什么样的对象(角色)可以马上解决我的问题呢？”

例如：假设你正在创建一个簿记系统，那么可以想象，系统应该具有某些包括了：预定义的簿记输入屏幕的对象，一个执行簿记计算的对象集合，以及一个处理在不同的打印机上打印支票和开发票的对象。

也许上述对象中的某些已经存在了，但是对于那些_并不存在的对象_，它们看起来是什么样子？它们能够提供哪些服务？它们需要哪些对象才能履行它的义务？如果持续这样做，那么最终你会说“那个对象看起来很简单，可以坐下来写代码了”，或者会说“我肯定那个对象已经存在了”。这是_将问题分解为对象集合的一种合理实践方式。_

## 四、隐藏具体实现

将程序开发人员按照角色分为类创建者和客户端程序员是大有裨益的：

1. 类创建者(那些创建新数据类型：类的程序员)
2. 客户端程序员(那些在其应用中使用数据类型的类消费者)

客户端程序员的目标是：收集各种用来实现快速应用开发的类。类创建者的目标是：构建类，这种类只向客户端程序员暴露必须的部分，而隐藏其他部分。

为什么要这样呢？因为如果加以隐藏，那么客户端程序员将不能访问它，这意味着**类创建者可以任意修改被隐藏的部分，而不用担心对其他任何人造成影响**。被隐藏的部分通常代表对象内部脆弱的部分，它们很容易被粗心的或不知内情的客户端程序员所毁坏，因此将实现隐藏起来可以减少程序bug。

**在任何相互关系中，具有关系所涉及的各方都遵守的边界是十分重要的事情。**

访问控制的原因：

1. 第一个存在原因就是让客户端程序员无法触及他们不应该触及的部分——这些部分对数据类型的内部操作来说是必须的，但并不是用户解决特定问题所需的接口的一部分。这**对客户端程序员来说其实是一项服务**，因为他们可以很容易地看出哪些东西对他们来说是很重要，而哪些东西可以忽略。
2. 第二个存在原因就是允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。如果皆接口和实现可以清晰地分离并得以保护，当你改变实现不影响接口的调用，那么就不会影响到客户端编程。

