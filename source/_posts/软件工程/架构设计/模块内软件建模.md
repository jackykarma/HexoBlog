---
title: 架构设计之模块内软件建模
date: 2022-07-11 06:57:34
tags: 组件架构设计
categories: 架构设计
---

一个大的系统被拆分系统、子系统，子系统再经过分层细化、分区、通用专用分离、机制提取，再通过模块间时序图验证后，就可以得到模块划分结果，模块时序图也可以帮助确定模块之间的接口，至此整个系统的架构设计就成型了，接下来就是并行开发各个模块。

因此要深入到模块内部，对模块进行更为详细的设计。模块内设计要解决的核心问题就是：

1. 如何有理有据的确模块内部的类、接口等？
2. 类之间的结构关系、行为怎样设计才更为合理，更符合业务模型？

> > 模块设计实际就是把模块内部的黑盒变为白盒的过程。

模块负责接收输入，然后产生输出。

**疑问**：如果在逻辑架构设计时，先将子系统划分为多个模块，这个模块如果是按照代码组织层面的功能来划分的，那么可能划分比较细，比如一个文件下载功能，如果按照实现层面的功能划分为请求构建

### 1.1. 需求建模

在需求模型中，**模块被看做是一个黑盒**（这点非常重要，不要试图去思考系统的内部任何细节，那些细节只会成为你定义功能与用例时的阻碍）。需求建阶段主要就是搞清楚模块的功能需求、非功能需求，并用规约明确下来，以便需求可追溯。

### 1.2. 分析建模

在分析建模阶段，要开发系统的静态和动态模型。静态模型定义了问题域类之间的结构关系。这些类及其关系描绘在类图中。**对象的组织准则**用来决定在分析模型中要考虑哪些对象。然后，开发动态模型来实现来自需求模型的用例，以显示每个用例参与的对象以及对象间是如何交互的。对象和它们之间的交互描绘在通信图或者顺序图中。在动态模型中，使用状态图来定义状态相关的对象。

在分析模型中，重点是*理解问题*；因此，重点在标识*问题域中的对象*以及对象之间的通信(传递的消息)。有些问题要推迟到设计阶段，例如对象是主动的还是被动的，消息发送是异步的还是同步的，以及接收对象调用哪些操作等。

在分析模型中，考虑的是对问题域的分析。其活动如下：

1. 静态建模：定义特定问题的静态模型。这是系统中提供信息的结构视图。类是由它们的属性及其和其他类之间的关系定义的。*操作在设计模型中定义*。对于信息密集系统，该视图是非常重要的。重点是在问题域中对现实世界的类进行信息建模。
2. 对象的组织：**决定参加每个用例的对象**。给出对象的组织准则以帮助确定系统中的软件对象：哪些是实体对象、边界对象、控制对象以及应用逻辑对象。在对象确定之后，对象之间的动态交互将在动态模型中描述。注意：有些对象需要延迟到设计阶段才能确定下来。因为这些对象在问题域中难以对应，而是在解空间才能显现出来（为了解决问题或是为了改善设计而产生的对象）。
3. 动态交互建模：实现用例来显示参与每个用例的对象之间的交互。开发通信图或顺序图来显示对象如何相互通信来执行用例。分为：**无状态的动态建模、有状态的动态建模方法**。
4. 动态状态机建模：系统的状态相关的视图使用层次状态图来定义。每个状态相关的对象由其状态图来定义。**设计有限状态机和状态图**

#### 问题域静态模型

1. 软/硬件系统上下文图
2. 软件系统上下文图
3. 软件系统上下文类图：可确定外部类，外部类通过对象组织准则又可以确定边界类。
4. 软件系统上下文类图：展示外部类与边界类
5. 实体类建模、类属性建模-\>实体类
6. 基于用例采用对象的组织准则确定其他附加对象：控制对象、边界对象、应用逻辑对象

确定问题域的类与对象，确定了参与用例的问题域对象。

#### 问题域动态模型

1. 每个用例的通信图、顺序图、消息序列编号、消息描述文档
2. 无状态的动态建模步骤
3. 有状态的动态建模步骤

确定问题域的对象之间的动态交互关系，用例对象之间的交互与消息。

### 1.3. 设计建模

在设计建模阶段，要设计系统的软件体系结构。在此阶段中，分析模型被映射到一个运行环境。分析模型(强调的是**问题域**)被映射到设计模型(强调的是**解域**)中。此阶段提供子系统的组织准则来讲系统组织为子系统。子系统被视为聚合或者聚接着设计每个子系统。对于顺序系统，重点放在信息隐藏、类和继承的面向对象的概念。对于并发系统的设计，例如实时的、客户端/服务器(C/S)和分布式应用，除了考虑面向对象的概念外，还需要考虑并发任务的概念。

1. 将动态模型的对象交互图进行集成，得到集成通信图
2. 子系统的组织准则划分子系统
3. 接着针对每个子系统的特性，采用对应的设计方法（顺序系统，采用面向对象设计方法）去设计子系统。此过程可能产生一些新的**解域对象**（这些对象的出现是在解域，是为了设计而产生的对象。）

***产物***：

1. 设计模型

在设计模型中，考虑的是解域、解空间。在这个阶段中，分析模型被映射到一个并发设计模型。为了设计软件体系结构，将执行以下活动：
1. 集成对象通信模型。开发集成的对象通信图。
2. 做关于子系统结构和接口的决策。开发总体的软件体系结构。将应用组织为子系统(划分子系统)。
3. 做关于在软件体系结构中使用什么**软件体系结构模式和设计模式**的决策。（根据子系统的体系结构特性来决策）
4. 做关于类接口的决策，特别是对于顺序软件体系结构。对每个子系统，设计信息隐藏类(被动类)。设计每个类的操作和每个操作的参数。
5. 做关于如何将分布式应用组织为分布式子系统的决策，其中子系统被设计成为可配置的构件，并且定义构件之间的消息通信接口。**C/S架构系统和分布式系统的区别**
6. 做关于对象特性的决策，特别是它们是主动的还是被动的。对于每个子系统，将系统组织为并发的任务(主动对象)。在任务的组织过程中，使用任务组织准则来组织任务，并定义任务的接口。
7. 做关于消息特性的决策，特别是它们是同步的还是异步的(要回复还是不要回复)。**体系结构通信模式、对象之间消息的类型**

COMET强调在**分析和设计过程中的特定阶段使用组织准则(*并不只在分析阶段使用*)**。对象组织准则用来帮助确定系统中的对象；子系统组织准则用来帮助划分和确定子系统；并发对象组织准则用来确定系统中并发(主动)对象。贯穿始终地使用UML构造型来清晰地显示组织准则的使用。

#### 设计软件体系结构

在软件设计建模期间，根据*软件体系结构的特性来作出设计决策*。本书中设计建模部分描述了不同种类的软件体系结构的设计：

1. 面向对象的软件体系结构：使用信息隐藏、类和继承的概念来描述面向对象设计。
2. C/S软件体系结构：一个典型的设计包含了一个服务器和多个客户端。
3. 面向服务的体系结构：它包含了多个分布式自治服务，这些服务能被组合成分布式软件应用。
4. 基于构件的分布式软件体系结构：可以在分布式配置的分布式平台上部署执行。
5. 实时软件体系结构：通常是用来处理多个输入事件流的并发体系结构。它们典型地依赖于状态，带有集中的或分散的控制。
6. 软件产品线体系结构：是为产品族的，需要捕获产品族中的共性和可变性。

在一个大型软件系统中，通常可能同时存在多个体系结构。因此，大型系统在设计阶段进行子系统划分，然后确定每个子系统的结构特性，接着针对每个子系统进行体系结构的确定，最后选择对应的体系结构设计方法进行详细设计。

对于软件密集型系统(即软件是一个更大的硬件/软件系统的组成部分)，系统建模可以在软件建模之前实施。UML有一个分支叫做**SysML**，它是一个面向系统工程应用的通用目的的建模语言。

### 1.4. 增量软件构建

在软件体系结构设计完成之后，就要采用**增量软件构建**方法。该方法是基于为每次增量选择系统的一个子集进行构建。子集的确定是通过选择要包含在该增量中的用例和参与这些用例的对象。增量软件构建包含了该子集中类的详细设计、编码和单元测试。这是一个分阶段的方法，通过该方法，软件被逐渐地构建和集成，直到整个系统构造完成。

### 1.5. 增量软件集成

在增量软件集成期间，要执行每个软件增量的集成测试。增量的集成测试是基于为该增量选择的用例。为*每个用例都要开发集成测试用例*。集成测试是白盒测试的一种形式，对参与每个用例的对象之间的接口都进行了测试。

每个软件增量形成一个增量原型。在软件增量被判定为符合要求后，就通过增量软件构建和增量软件集成这两个阶段进行迭代，构建和集成下一个增量。然而，如果在软件增量中检测出问题，那么可能就需要在需求建模、分析建模和设计建模中进行迭代。

### 1.6. 系统测试

系统测试包括**系统的功能测试**，即针对系统的功能性需求测试系统。这种测试是黑盒测试，基于黑盒用例。因此，要为每一个黑盒用例构建功能**测试用例**。发布给客户的任何软件增量都需要经历系统测试阶段。

## 二、需求建模

当分析模块需求时，将模块看做是一个黑盒，思考该模块的输入输出，模块的功能、质量、约束等需求。

功能需求：

1. 描述系统需要提供什么功能？
2. 哪些信息需要从外部环境(例如外部用户、外部系统或外部设备)输入给系统？【输入】
3. 哪些需要由该系统输出给外部环境？【输出】
4.  哪些存储信息该系统要读取或更新？【数据存储访问】

非功能性需求：质量属性、约束条件。系统的质量属性，是指系统必须满足的服务质量目标。比如：可维护性、可修改性、可测试性、可追踪性、可扩展性、可复用性、性能、安全性、可用性。

以下属性被认为是有利于写好的软件需求规约SRS：Software Requirements Specification：

1. **正确**。每个需求都是对用户需要的精确解释。
2. **完整**。SRS包含了每个有意义的需求。另外SRS需要定义系统对每个可能输入的响应Response，无论输入是正确的或错误的。最后，不应有任何的“待定”。
3. **无二义**。每个陈述的需求只有一个解释。模糊的陈述都必须被替换。
4. **一致**。这是指确保单个需求之间不冲突。可能会有冲突的术语，例如两个术语都意指同一个概念；可能会有冲突的需求，例如一个需求做出了一个关于其所依赖需求的错误假设；还可能在后续的阶段添加一个新需求时，会和已有的需求冲突。
5. **可验证**。需求规约实际上是开发者和客户机构之间的合同。软件验收标准是开发自需求规约的。因此，每个需求能被测试以可确定系统满足需求是必要的。
6. **非计算机专家能够理解**。因为系统的用户很可能是非计算机专家，所以需求规约以易理解的叙述文字书写是很重要的。
7. **可修改**。因为需求规约很可能经过多次迭代，并且系统部署之后也需要演化，所以需求规约可修改是必要的。为了辅助该目标，SRS需求要目录、索引以及交叉引用。每个需求应该只在一个地方陈述，否则，不一致性就可能蔓延到规约中。
8. **可追踪**。需求规约需要能反向追踪到系统级需求和用户需要，同时，也需要能向前追踪到满足需求的设计部件和实现需求的代码部件。

### 2.1. 需求建模方法

1. 功能树图：定义功能列表的时候关键是要知道什么才能称之为功能，系统功能性需求不能与软件设计师的设计需求（属于非功能性需求）搞混。需将功能性需求从产生于设计或实现决策的功能中分离出来。功能树图的关键点是：
	- 面向价值，体现使用价值；无直接价值的中间结果或过程，不应列入功能列表。
	- 覆盖全面，没有范围遗漏。
2. 模块上下文图：是一种辅助说明**需求范围**的方式，它清晰地描述了待开发模块与周围所有事物之间的界限与联系。
3. 用例模型：没有必要针对每个用例写用例规约，只需要针对关键用例写用例规约即可。


## 三、分析建模：静态建模

> > 静态建模的主要工作就是尽可能识别出参与用例的对象，确定类之间的关联关系和类的属性。这样后面的对象间的动态建模才能进行下去。但是静态建模只能确定

静态建模展示的是问题的**静态结构视图**，静态建模分两个阶段进行：

1. 问题域的静态建模：重点是对物理类和实体类建模。
	- 物理类：是具有物理特性的类——即它们能被看到和摸到。主要包括物理设备、用户、外部系统和计时器（边界类对象）。
	- 实体类：是概念上（包含抽象的）的数据密集型类，通常是持久的。
2. 解空间的静态建模：设计阶段。解决方案域的静态建模被延迟到设计阶段。尽管静态建模也包括定义每个类的操作，但在动态建模后确定一个类的操作会更加容易。因此，确定一个类的操作被延迟到类设计阶段。

输入：用例模型
输出：

1. 系统的概念静态建模
2. 软硬件系统的上下文类图建模：顶层类图（一般软件模块就没必要）
3. 软件系统的上下文类图建模：顶层类图
4. 确定外部类对象
5. 确定实体类、实体类之间的静态关系以及实体类属性

对象与类的确定是分两个阶段才能完全确立的：

1. 问题域对象problem domian objects：基于现实世界的问题域，通过用例和静态建模分析提取的类与对象，这是系统对象的一部分。可以**在分析建模阶段确定下来**，并可以对他们进行分类。
2. 解域对象solution domain objects：基于解空间的对象，这些对象不对应现实世界的具体事物，它可能是为了解决问题而需要抽象出来的一个对象；**在设计阶段才能确定**下来。


本节解决的是*真实世界中发现的问题域对象，而不是在设计时确定的解空间对象。*

1. 如何确定系统中的软件对象和类，提供了对象和类的构造标准，并通过使用构造型对对象和类分类。
2. 重点是那些要在真实世界中发现的问题域对象和类上，而不是那些在设计时确定的解域对象。
3. 在动态交互建模期间，*对象和构造标准通常依次应用于每个用例上*，*以确定参与到每个用例中的对象。然后，对象之间的交互序列被确定。*

### 3.1. 类之间的静态关系

> > 类之间的静态关系，如果有现成的设计模式能提供更好的结构，那么直接使用设计模式更快的构建良好的类结构和关系。

类之间的静态关系具有多重性：

1. 一对一关联
2. 一对多关联
3. 规定数值关联
4. 可选关联
5. 多对多关联

三元关联-\>关联类(协商类)：三元关联是在类之间的三个方向的关联。三元关联的一个例子是“买方Buyer”、“卖房Seller”和“中介Agent”三个类之间的关联。该关联是“买方”通过“中介”和“卖方”协商价格。

![](IMG_4812.jpg)

一元关联：一元关联也称为自身关联是一个类的一个对象与同一个类的另一个对象之间的关联。例如“人Person”是“人Person”的孩子(Is child of)， “人”与“人”结婚（Is married to），“雇员”是“雇员”的老板(Is boss of)。

关联类：关联类是**对两个或多个类之间的关联进行建模的类。**关联类的属性就是该关联的属性。在两个或多个类之间的复杂关联中，关联是有可能拥有属性的。

这经常发生在多对多关联中，其中属性不属于任何一个类，而是属于该关联。

![](IMG_4814.jpg)

组合和聚合：组合和聚合都是关系的特殊形式：类通过整体/部分关系连接起来。在这两种清空下，部分和整体间的关系是一个Is part of关系。**组合是一种比聚合更强的关系，**聚合是一种比关联更强的关系。特别地，组合关系是一种在部分和整体之间比聚合关系更强的关系。组合也是实例之间的关系。因此，部分对象的创建、存在和消亡都是和整体一起的。部分对象只属于一个整体。雁群是聚合关系，大雁与雁尾巴是组合关系。

泛化与特化层次/继承：在泛化/特化层次中，共同属性被抽象到一个泛化类，称作超类。在子类和超类之间有一个Is a 的关系。超类也被称为父类或祖先类。子类也被称为孩子类或者子孙类。**区分器**：是表明对象的哪个性质被泛化关系用来进行抽象的一种属性。例如，上述“账户”泛化中的区分器“账户类型accountType”区分了“活期账户”和“储蓄账户”。区分器并不需要成为泛化类或特化类的一个属性。因此，它不是“账户”超类或其两个子类的属性。

![](IMG_4817.jpg)

约束：约束规定了必须为真的条件或限制。约束可以使用任何文本语言表示。UML也提供了一种约束语言——对象约束语言OCL，可以选择性地加以使用。

![](IMG_4818.jpg)

### 3.2. 对象和类的组织准则：

1. 没有一个统一的方式将一个系统分解为对象，因为做出这些决策都是基于分析员的判断和问题的特性。
2. 对象是否是同一个类或是不同的类依赖于问题的本质。例如，在汽车分类中，轿车、卡车可能是同一个类的对象；然而，对于汽车制造商而言，它们可能是不同类的对象。

本文给出的对象和类的构造标准旨在**辅助设计者将一个系统构建成对象**。用来标识对象的方法是在问题域中寻找真实世界对象，然后设计相对应的软件对象对真实世界建模。在标识出这些对象之后，对象之间的交互就在动态模型的通信图或顺序图中描述出来。

实体类是信息密集的，因此在分析阶段的静态建模中通常就可以确定。但是，实体类只是系统中软件类的一种。**在着手动态建模之前，有必要确定需要哪些软件类和对象来参与实现每一个用例。**

对象和类的组织标准可以提供很大的辅助作用，这些标准为将一个应用构建成对象提供了知道。这种方法是通过它们**在应用中所扮演的角色**来对软件类和对象进行分类。

此步骤中：

1. 类被分类，使得带有相似特性的类被分组到一起。
2. 展示了应用类的分类与构造型。构造型被用来区分不同种类的应用类。因为对象是类的实例，所以对象拥有和它所实例化的类相同的构造型stereotype。

![](%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-26%2021.46.45.png)

#### 对象和类的组织分类原则

对象和类是根据他们在应用中所扮演的角色类分类的。有四个主要的对象和类的构造分类

1. *实体对象*：一种软件对象，很多情况下是持久的，封装了信息并提供对他所储存信息的访问。在某些情况下，实体对象可以通过服务对象访问。
2. *边界对象*：连接到外部环境并与之通信的软件对象。边界对象进一步分类如下：
	- **用户交互对象**：与人类用户进行交互并通过接口连接到人类用户的软件对象。比如屏幕窗口
	- **代理对象**：连接到外部系统或者子系统并与之通信的软件对象。
	- **设备I/O边界对象**：从硬件输入/输出设备接收输入或向硬件输入/输出I/O设备输出的软件对象。键盘 鼠标等
3. *控制对象*：对对象的集合提供**全局协调**的软件对象。控制对象可以是：
	- **协调者对象**
	- **状态相关控制对象**
	- **计时器对象**
4. *应用逻辑对象*：包含应用业务逻辑细节的软件对象。当希望从正在操纵的数据中分开隐藏应用逻辑时需要这种软件对象，因为我们认为有可能应用逻辑会独立于数据发生变化。对信息系统而言，应用逻辑对象通常是**业务逻辑对象**，而对实时应用、科学应用功能或工程应用而言，应用逻辑对象通常是**算法对象**。另一个分类是**服务对象**，为客户对象提供服务，典型地存在与面向服务的架构和应用中。

大多数情况下，一个对象属于哪个分类是显而易见的。然而，在某些情况下，一个对象有可能满足上面标准中的多个。如此情况下，可以将该对象分配给看上去更合适的分类。注意，更重要的是要确定系统中的所有对象，而不是过分关心如何分类少量模棱两可的情况。

**对每一个对象结构组织准则，有一个对象行为模式（设计模式的一个分类），它描述了该对象如何与其相邻对象进行交互。**

#### 外部类与软件边界类

外部类是那些在软件系统外部并且通过接口连接到系统的类。边界类是系统内部的类，通过接口连接到外部类并与其通信。为了帮助确定系统中的边界类，有必要考虑和它们相连的外部类。

外部类用一下方式通过接口连接到软件边界类：

1. **外部用户类**通过接口连接到**用户交互类**，并与之通信。
2. **外部系统类**通过接口连接到**代理类**，并与之通信。
3. **外部设备类**为设备I/O边界类提供输入和/或接收其输出。继续分类为：
	- 外部输入设备类向输入类提供输入。
	- 外部输出设备类接收来自输出类的输出。
	- 外部I/O设备类向I/O类提供输入并接收其输出。
4. **外部计时器类**向软件计时器类发信号。

一个外部设备类代表一个I/O设备类型。一个外部I/O设备对象代表一个特定的I/O设备，即该设备类型的一个实例。

##### 用户交互对象

**用户交互对象**直接与人类用户通信，从用户获取输入，通过标准I/O设备（如键盘、显示器和鼠标）向用户提供输出。依赖于用户接口技术，用户接口可能非常简单（比如命令行接口），也有可能更复杂（比如图形化用户界面GUI对象Activity）。用户交互对象可以是一个*组合对象*，由几个较简单的用户交互对象组成。这意味着用户通过多个用户交互对象与系统交互。这些对象用《用户》(user interaction)构造型描述。

例如：“操作员交互”对象可以是由几个简单的用户交互对象组成而成的组合用户交互对象。这就允许操作员在**一个窗口**中接收工作站状态的动态更新，在**另一个窗口**中接收警报状态的动态更新，在**第三个窗口**中与系统进行交互式对象。每一个窗口都是由多个GUI部件组成，比如菜单、按钮和更简单的窗口。

![](IMG_4868.jpg)

##### 代理对象Proxy

代理对象通过接口连接到外部系统并与之通信。*代理对象是外部系统的本地代表，隐藏了“如何”与外部系统通信的细节。*

每一个代理对象都隐藏了如何通过接口与特定外部系统连接并与之通信的细节。代理对象更有可能通过向外部的计算机控制的系统发送消息的方式进行通信，而不是向设备I/O边界对象那样通过传感器和执行器来通信。然而，这些问题都要到*设计阶段*才会处理。

![](IMG_4869.jpg)

##### 设备I/O边界对象

*设备I/O边界对象对一个硬件I/O设备提供软件接口(读/写)。*
1. 设备I/O边界对象对*非标准*的特定应用I/O设备是必需的，这些非标准设备在实时系统中更加普遍，尽管它们在其他系统中也经常用到。
2. *标准*I/O设备典型地由操作系统来处理，因而专用设备I/O边界对象不需要作为应用的一部分来开发。

**输入对象**：是一种设备I/O边界对象，从一个外部输入设备获取输入。比如真实世界的传感器硬件与软件的输入对象(传感器读取接口软件对象)。【软/硬件边界】

![](IMG_4870.jpg)

**输出对象**：是一个设备I/O边界对象，向外部输出设备发送输出。

![](IMG_4871.jpg)

**输入/输出对象**：是一种设备I/O边界对象，从外部I/O设备接收输入，并向外部I/O设备发送输出。

![](IMG_4872.jpg)

*对每一个真实世界对象都由一个设备I/O对象的方式来建模，所有这些对象都是同一个类的实例*。例如，工厂自动化系统控制了许多自动引导的车辆，拥有许多相同类型的车辆发动机和相同类型的机械臂。对每一个自动引导的车辆，都有“发动机接口Motor Interface”类的一个实例和“机械臂接口Arm Interface”类的一个实例。

![](IMG_4873.jpg)

#### 实体类和对象

**实体对象**是存储信息的软件对象。实体对象是实体类的实例，这些实体类的属性和其他实体类的关系在静态建模时被确定。*实体类对象存储数据，并通过他们提供的操作为这些数据提供有限的访问。*

在许多信息系统的应用中，通过实体对象封装的信息被存储在文件或数据库中。具体存储方式的问题会在设计阶段被解决。

#### 控制类和对象

**控制对象**：提供了实现一个用例的对象的总体协调。

简单的用例不需要控制对象。然而，在一个较复杂的用例中，通常需要控制对象。控制对象类似于乐队的指挥，它指挥（控制）其他参与该用例的对象的行为，*通知每个对象在何时做什么*。依赖于用例的特性，控制对象可以是状态相关的。控制对象有多个种类：

##### 协调者对象

**协调者对象**：是做出总体决策的对象，它确定了相关对象集合的总体顺序安排。经常需要协调者对象为用例的执行提供总体的顺序安排。它做出总体决策，并决定其他对象何时、以何种顺序参与到用例中。

1. 协调者对象根据它接收输入做出决策，并且不是状态相关的。因此，由协调者对象发起的动作只取决于包含在传入消息中的消息，而不依赖于系统中之前发生的事情。

	![](IMG_4875.jpg)

2. 另一种协调者是面向服务应用中的协调者对象，它协调在一个用户交互对象和一个或多个服务对象之间的交互。

##### 状态相关的控制对象

**状态相关的控制对象**：是一种*在不同状态下其行为有变化*的控制对象。

1. 有限状态机用于定义状态相关的控制对象，并用状态图来描述。
2. 状态相关的控制对象接收引起状态转移的输入事件entry，并产生控制其他对象的输出事件output。
3. 由状态相关的控制对象产生的输出事件不仅依赖该对象接收的输入，还依赖对象的当前状态。
4. 在一个控制系统中，通常由一个或多个状态相关的控制对象，也可能拥有多个相同类型的状态相关的控制对象。尽管每个对象都可能出在不同的状态，但它们都执行同一个有限状态机的一个实例。

##### 计时器对象

**计时器对象**：是一个由外部计时器（如实时时钟或操作系统时钟）激活的控制对象。计时器对象要么自己执行某个动作，要么激活另一个对象来执行期望的动作。

![](IMG_5518.jpg)

#### 应用逻辑类和对象

应用逻辑对象包含三种类型：

1. 业务逻辑对象
2. 算法对象
3. 服务对象

和控制对象一样，应用逻辑对象更可能在**开发动态模型时**被考虑，而不是在开发初始的静态模型时被考虑。

##### 业务逻辑对象

**业务逻辑对象**：定义了用于处理一个客户端请求的特定业务的应用逻辑，其目标是将可能相互独立变化的业务规则（隐藏）到分离的业务逻辑对象中。另一个目标是将业务规则从它们操作的实体数据中分离出来，因为业务规则可以独立于实体数据而变化。通常是*业务逻辑对象在其执行期间访问各种实体对象*。

业务逻辑对象只在特定情况下需要。有时，有以下两种选择：

1. 将业务逻辑封装到分离的业务逻辑对象中
2. 如果业务规则足够简单，就把它作为一个实体对象的操作。这种选择的指导思想是：如果业务规则只有通过访问两个或更多的实体对象才能执行，就应该有一个分离的业务逻辑对象；如果访问一个实体对象就足以执行业务规则，则可以将它作为该对象的一个操作。

业务逻辑类的一个例子是“取款交易管理器”类，它为ATM客户的取款请求服务，它封装了处理ATM取款请求的业务规则。例如，第一个业务规则是：客户在取款后必须至少要有50元的余额。第二个业务规则是每日取款不能超过250元。

*业务逻辑对象通常必须和实体对象交互，以便执行其业务规则。*这样看来，它类似于协调者对象。然而，业务逻辑对象的主要职责是*封装和执行业务规则*，这一点上它不像主要职责是*监督其他对象的*协调者对象。

##### 算法对象

**算法对象**：封装问题域中使用的算法，该种对象在实时、科学和工程领域中更加普遍。当有问题域中使用了一个*独立于其他对象而变化的重要算法时，*就要使用算法对象。

1. 简单的算法时实体对象的操作，操作封装在该实体类内的数据。
2. 在科学和工程的许多领域，算法别迭代地精化，因为它们独立于它们所操作的数据而改进。

算法对象经常封装了计算其算法所需要的数据。这些数据可以是初始化数据、中间结果数据或阈值数据（例如最大值或最小值）。

算法对象必须频繁地和其他对象交互，以便执行算法。这样看来，它类似于一个协调者对象。然而，*算法对象的主要职责是封装和执行算法*，这一点上它不像主要职责是*监督其他对象的*协调者对象。

![](IMG_5520.jpg)

##### 服务对象

**服务对象**：是为其他对象提供服务的对象，它们通常在面向服务的架构和应用中提供。

客户端对象能从服务对象请求一个服务，服务对象将作出响应。服务对象绝不会发出一个请求；然而，在响应服务请求时，它可能会寻求其他服务对象的帮助。服务对象在面向服务的架构中扮演重要的角色，尽管它们也被用在其他的架构中，例如*客户端/服务器体系结构和基于构件的软件体系结构*。服务对象可能封装了它需要用来服务客户端请求的数据，或者访问其他封装了该数据的实体对象。

![](IMG_5521.jpg)

### 3.3. 确定物理类

物理类是具有物理特性的类——它们能被看到和摸到。包括物理设备、永不、外部系统和计时器。物理类，主要包括外部类。另外还有一些个就是显而易见的现实世界存在的，是具体的存在，不是抽象的。比如银行系统的“银行”就可以实际对应一个银行类，“现金”就可以实际提取一个物理类：现金类。


![](IMG_4820.jpg)

一个通用的指南是：

1. 只有在用户通过标准I/O设备与系统交互时，人类用户才要表示为一个外部用户类。
2. 如果用户通过特定于应用的I/O设备和软件系统进行交互，那么这些I/O设备就要表示为外部输入/输出设备类。

![](IMG_4822.jpg)

参与者是一个比外部类更抽象的概念。参与者和外部类之间的关系如下：

1. **输入/输出设备参与者**等同于外部输入/输出设备类。这意味着输入/输出设备参与者通过外部输入/输出设备类连接到系统。
2. **外部系统参与者**等同于外部系统类。
3. **计时器参与者**通过外部计时器类连接到系统，外部计时器类向系统提供计时器事件。
4. **人类用户参与者**有最大的灵活性。在最简单的情况下，通过标准设备连接到系统。更复杂的情况是，人类参与者有可能通过多种外部类连接到系统。

![](IMG_4823.jpg)

### 3.4. 确定边界类

![](IMG_4331.jpg)

*外部类是那些在软件系统外部并且通过接口连接到系统的类。*

边界类是系统内部的类，通过接口连接到外部类并与其通信。为了帮助确定系统中的边界类，有必要考虑和它们相连的外部类。

外部类用以下方式通过接口连接到软件边界类：

1. **外部用户类**通过接口连接到**用户交互类**，并与之通信。
2. **外部系统类**通过接口连接到**代理类**，并与之通信。
3. **外部设备类**为设备I/O边界类提供输入和/或接收其输出。继续分类为：
	- 外部输入设备类向输入类提供输入。
	- 外部输出设备类接收来自输出类的输出。
	- 外部I/O设备类向I/O类提供输入并接收其输出。
4. **外部计时器类**向软件计时器类发信号。

一个外部设备类代表一个I/O设备类型。一个外部I/O设备对象代表一个特定的I/O设备，即该设备类型的一个实例。

### 3.5. 确定实体类

实体类：是概念上的数据密集型类。因此，用例描述中的概念性名词或是问题域中可提取的抽象概念，都可能是实体类。注意，有些实体概念不一定可以从当前的用例描述中直接发现和提取出来。可能需要对问题域的分析，**抽象出一些概念**出来。

实体类通常在设计阶段映射到数据库。实体类概念性分两种：

1. 现实世界物理概念实体：每一个现实世界物理概念实体都被建模为一个实体类。比如客户对象。
2. 抽象的概念实体：比如现实世界中看不见摸不着的，但是确是存在的抽象概念或是数字概念，比如“交易”、“订单”，“调度器”，“控制中心”。

实体类建模时，对每个实体采用《entity》构造型进行附加描述。

![](IMG_4839.jpg)

在对实体类的建模中，一个重要的考虑是定义每个实体类的属性。实体类是**数据密集型的**，这意味着它有多个属性。

如果一个实体类看上去只有一个属性，那么它是否真的是一个实体类就有问题了。事实上，这个有疑问的实体更有可能应该建模为另外一个类的属性。

### 3.6. 识别问题域其他对象

**此处强调问题域对象，至于解空间的对象，是要到设计阶段综合设计需求与实际方案设计才产生的对象，要到设计建模阶段才能确定。**

依据用例模型识别其他对象。

## 四、分析建模：动态建模

**动态交互建模是基于在用例建模阶段开发的用例的实现进行的**。对于每一个用例来说，有必要去确定每一个参与的对象是怎样在用例中和其他的对象进行动态交互的。

在分析模型中，**消息表示对象之间的信息传递**。

1. _利用交互图可以帮助确定对象的操作，因为消息的抵达通常会调用操作。
2. _在COMET里，分析建模的重点是捕获对象之间传递的信息，而不是被调用的操作。_

推迟到设计阶段的决策：

1. 在设计过程中，我们可能会决定让到达同一个对象的两个不同消息去调用不同的操作，也可能会调用一个相同的操作，只是把消息名作为操作的参数。然而，这些决策需要**推迟到设计阶段**来进行。
2. 对象(同步或异步)间传递的消息类型。

在分析阶段，所有在对象之间传递的信息都是**简单的消息**。主要输出：

1. 通信图、顺序图
2. 交互图上的消息序列编号与消息描述

用例和场景：

场景：是用例的一条特定路径。因此，一个交互图上特定的消息序列其实描绘的是一个场景而不是一个用例，场景是用例中一个特定的消息序列或路径分支。要想把一个用例的所有可能路径都显示出来通常需要**超过一张交互图**。虽然可以将所有路径都画在一张通信图中，但是有时候可能会导致交互图过于复杂难以读懂。在实践中，用一张交互图来描述一个单独的场景scene通常会更加清晰。同样，利用**有循环结构和分支结构**的顺序图，也可以把整个用例的所有交互序列描绘出来，包括主序列和其他可替换序列。

通用和实例形式的交互图：

实例形式：用来详细地描述一个一个特定的场景scene，把一个可能的对象实例间的交互序列描绘出来。它用来描述一个特定的场景，这个场景通常是用例中的一个实例。

通用形式：用来描述参与交互的对象之间所有可能的交互关系，因此会包含循环、分支和条件。既可以用来描述主序列，也可以描述可替换序列的序列。

实例形式的交互图会比通用形式的交互图更加清晰。

### 4.1. 消息序列

消息标签语法：

`[ 序列表达式 ]: 消息名称 (参数列表)`。其中，序列表达式包含了消息序列的编号和一个重现的指示器。

1. **消息序列编号**：第一个消息序列编号代表通信图上的某个消息序列的事件的起始：
	- 典型形式：自动累加的如1，2，3，…; A1, A2, A3, …。
	- Dewey分类系统来描述：例如A1.1.1紧跟着A1.1，然后是A1.2。如此更加精细。典型的序列是A1，A1.1，A1.1.1，A1.2.
2. **循环**：循环的部分是可选的，它代表了条件或迭代的执行。循环的部分代表了当满足一定条件的情况下会发送零条或多条信息。
	- \*[ 迭代语句 ]。在一个消息序列编号后面加上一个星号(\*) 表示要发送超过一条的消息。这个可选的迭代语句是用来指定重复的执行，例如 [ j:= I,n]。一个在消息序列编号后加上星号来代表迭代的例子是3\*。
	- [ 条件语句 ]。放在中括号里的一个条件用来指示一个分支条件。这个可选的条件语句是用来指定分支结构的。例如[x\<n]，意味着只有当这个条件判断为真的时候，消息才会发送出去。例如，跟一个消息序列编号后面的条件4[ x \< n]和5[Normal]就是有条件的消息传递的例子。
3. **消息名称**：消息名称是固定的。
4. **参数列表**：消息的参数列表是可选的，它指定了所有要随着消息一起发送的参数。_在分析阶段建议只是使用一些简单的消息，不要带返回值，把应该使用哪种消息类型这个问题推迟到设计阶段去考虑。_

编号：

一个用例的消息序列编号的形式如下：
_[ 第一个可选的字母序号 ][ 数字序号 ][ 第二个可选的字母序号 ]_

1. 第一个可选的字母序号：是一个可选的用例ID，它表示了一个用例是一个特定的具体的用例还是一个抽象的用例。第一个字母是一个大写字母，后面如果需要描述性用例ID的话，可能跟着一个或多个大写或小写字母。

最简单的消息序列的形式是用一个整数序列表示，例如M1, M2和M3。但是，在一个有着**多个外部参与者输入**的交互系统当中，带有一个小数的数字序列可能会更有用，也就是说，用_整数来表示外部事件，而用跟在后面的小数表示内部事件。_例如，如果参与者的输入被指定为A1, A2  和 A3，则完整的通信图消息序列应当是A1， A1.1, A1.2, A1.3,…,A2, A2.1, A2.2, …,A3, A3.1, A3.2, …。

一个例子是V1, 其中V代表用例ID，数字代表支持用例的通信图的消息序列。发送第一个消息的对象V1是这个用例基于通信的启动者。因此参与者的输入都是从V1开始的。后续的消息编号是V1.1，V1.2和V1.3，如果对话还将继续的话，下一个参与者的输入将从V2开始编号。

并发和可替换的消息序列：

_[第二个可选的字母序号]_是用来描述一些特殊的分支情况：要么是并发情况，要么是备选情况。

_并发的消息_：也可以在一个通信图中描绘，一个小写的字母表示一个并发序列，也就是说被指定为**A3和A3a**的序列是并发的序列。例如，消息A2到达X对象，会触发X向Y,Z同时发送消息。那么假设X-\>Y的消息时A3，那么X-\>Z就是A3a。A3序列中后续的消息就被指定为A4, A5, A6, …, 而A3a序列的后续消息会被指定为A3a.1, A3a.2,A3a.3, 如此继续。因为A3a的后续序列编号更加复杂，因此用A3来表示主消息序列，A3a，A3b这样的编号表示**支持性消息序列**。

另外一种显示两个并发序列的方法是避免使用A3，而是直接使用A3a和A3b，当然，这种方法也有问题，如果A3a又产生了两个新的并发序列，整个编号模式将变得非常负责，因此更加推荐第一种方法。

_可替换消息_：可替换消息序列用消息之后跟着的条件来描述。一个大写字母用来命名一个可替换的分支。例如，主分支可能标记为1.4[Normal]，另外不常用的分支则可能被标记为1.4A[Error]。正常Normal分支的消息序列编号可能是1.4[Normal]， 1.5, 1.6, 如此继续。可替换分支的消息序列编号可能是1.4A[Error], 1.4A.1, 1.4A.2， 如此继续。

消息序列描述：

消息序列描述是一种**支持性**的文档，一般和交互图一起提出。描述的是分析模型对象是如何参与到交互图中描绘的每一个用例中。

**消息序列描述是一个叙述性描述，描述了当每个消息到达通信图或顺序图上的目标对象时会发生什么。**

示例：
```js
A1: "监控操作员"请求一个警报处理服务——比如，查看警报或者订阅某一个特殊类型的警报消息。这个请求被发送到“操作员交互”。
A1.1: "操作员交互“ 发送警报请求给”警报服务“。
A1.2: ”警报服务“执行请求——例如，阅读现有警报的列表或者添加用户交互对象的名字到订阅列表中——然后发送响应返回给”操作员交互“对象。
A1.3: ”操作员交互“显示响应——例如，警报信息——给操作员。
```

### 4.2. 无状态的动态交互建模步骤

1. 开发用例模型
2. 确定在实现用例时所需的对象
	- 确定边界对象：要先根据上下文类图确定外部类，然后确定与外部类通信的边界对象。
	- 确定内部软件对象：采用对象结构组织准则来首先确定参与用例的内部软件对象，例如控制对象或者是实体对象。
3. 确定消息序列：参与用例的对象间的动态交互。
4. 确定可替换序列。

### 4.3. 基于状态的动态交互建模：有限状态机

**有限状态机**用来对系统或对象的**控制和顺序**视图进行建模。很多系统例如实时系统与状态高度相关。也就是说，_系统的行为不仅取决于输入，也取决于系统之前所发生的事件(系统当前的状态)。_

定义有限状态机的表示法有：

1. **状态转换图**
2. **状态图**
3. **状态转换表**

_扁平化状态图flat statechart_：传统的不分层的状态转换图。
_层次化状态图hierarchical statechart_：层次化状态分解

#### 有限状态机(主要是扁平的)

1. 有限状态机：也称为状态机state machine，是包含**有限个状态**的概念化机器。
2. 状态转换：是由输入事件引起的状态的改变。下一个状态依赖于当前状态和输入事件，该事件可能没有作用也可能有作用。有时，**状态转换会导致输出动作**
3. 在面向对象设计OOP中，一个有限状态机常被封装在一个对象内部。换句话说，这个对象是与状态相关的，并总是处于有限状态机中的某一个状态。对象的有限状态机通过状态图来描绘。
4. 在OOP模型中，一个系统的状态相关的视图通过一个或多个状态机定义，每一个有限状态机被封装在它自己的对象里。

#### 事件Event

**事件：**是指在某一个时刻/时间点发生的事情，事件也被称为离散事件、离散信号或激励Motivation。

1. _一个事件具有原子性_(一旦发生就要执行完，不可中断)且在概念上无持续。“卡片已经插入”、“Pin码已经输入”、“门已开”等都是事件。
2. _事件会相互依赖_：例如，事件“卡片已经插入”总是在“Pin码已经输入”之前发生。
3. _一个事件可以源自外部_：例如“卡片已经插入（是用户将卡片插入到读卡器的结果）”，也可以通过系统内部生成，例如“有效PIN码（Valid PIN）”

![](%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-09%2010.16.36.png) 
简单的状态转换图：不带警戒条件 

##### 事件带警戒条件

通过使用警戒条件，可以使**状态转换具有条件性**。

_表示法：事件[ 条件 ]_

条件是某一段时间内值为true或false的布尔表达式。加入方括号内警戒条件的值为真，并且事件发生，就会导致状态发生转换。另外，条件是可选的。

![](%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-09%2010.55.37.png)

#### 状态State

**状态：**表示一种可识别的、存在于一段时间间隔内的情况。

1. 与事件不同，一个有限状态机在一段时间内总处于一个给定的状态。
2. 理论上说，状态转换不需要时间。而实际上，和状态内部持续的时间相比，状态转换发生的时间可以忽略不计。
3. 初始状态：指状态机被激活时进入的状态。

![](%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-09%2010.45.47.png)
 

#### 动作Action

**动作**：是与状态转换相关的可选的输出。

1. 动作执行了计算，作为状态转换的结果。
2. 事件导致状态的转换，而动作是状态转换所产生的_结果_
3. 动作在状态转换时被触发Trigger。它执行，随后自行终止。
4. 动作在转台转换时立即执行，因此理论上说一个动作的持续时间为0。实际上，与状态持续的时间相比，动作持续的时间很短。

_进入动作Enter Action：_当进入状态时，进入动作被触发；
_退出动作Exit Action_：当退出状态时，退出动作被触发。

##### 状态转换中的动作

**转换动作**：是指当从某一个状态转换为另一个转太时所产生的动作，该动作也可能发生在状态转换至自身状态时。

描述方法：“_事件/动作”(Event/Action) 或者”事件[条件]/动作_”（Event[Guard]/Action）

![](%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-09%2011.09.02.png)

##### 进入动作Entry Action

**进入动作**：是指在开始进入该状态时触发的_即时动作_。

1. 进入动作通过保留字“进入/entry”来表示，在状态框里表示为“进入/动作（entry/Action）”
2. **进入动作的使用场合**：
	- 有多个状态转换进入到该状态。
	- 在每次状态转换进入到该状态时都需要执行同一动作。
	- 某一动作在进入该状态时执行，而在前一状态退出时不执行。

上述使用场合下：
1. _动作只能显示在状态框内，而不是显示在进入该状态的每个状态转换中(箭头线Transition的Trigger中)_
2. _如果动作只是在某些状态转换时执行，而不再其他状态转换时不执行，这样就不要使用进入动作。同时，转换动作应该使用在相关类的状态转换过程中Transition_

提取相同Action

![](%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-09%2011.22.53.png)

##### 退出动作Exit Action

**退出动作**：是指在离开该状态时触发的即时动作。

1. 退出动作通过保留字“退出”(exit)来表示，在状态框里表示为“退出/动作(exit/action)”。
2. **退出动作的使用条件**：
	- 有多个状态转换来退出该状态
	- 在每次状态转换退出该状态时都需要执行同一个动作。
	- 某一个动作在退出该状态时不执行，而在下一个状态进入时不执行。

退出动作同样只能在状态框中设定，而不能在Trasition状态转换的过程中设定，这与Entry Action是类似的。

#### 层次化状态图

_扁平化状态图的一个潜在的问题_：随着状态和状态转换的不断增长，状态图会变得杂乱并难以阅读。为了简化状态图并增加其建模能力，引入**复合状态**和状态图的**层次化分解**是和重要的方法。

主要目标：_状态图中的某个层次的复合状态可被分解为低层次状态图中的两个或多个子状态。_ 每个层次化状态图都可以映射为一个扁平化状态图。

##### 层次化状态分解

复合状态被分解为两个或多个相互关联并有先后顺序的子状态，这种分解称为“*顺序化状态分解*”。

可以将复合状态和子状态显示在同一个图中，也可以显示在单独的图中。这取决于分解的复杂度。

##### 复合状态

复合状态在状态图中有两种表达方式：
1. 一个复合状态可以和其内部子状态一起显示出来
2. 复合状态可以表示为一个黑盒，不透露其内部子状态。

*需要指出的是：当复合状态被分解为多个子状态时，**必须要保留进入和离开该复合状态的状态转换**。*

##### 状态转换的聚合

状态图中离开每个子状态的状态转换可以聚合成离开复合状态的状态转换。巧妙地使用该特征，可显著减少状态图中状态转换的数量。

![](%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E5%B1%82%E6%AC%A1%E5%8C%96%E8%A7%86%E5%9B%BE%EF%BC%9A%E5%AD%90%E8%A7%86%E5%9B%BE.png)

##### 正交状态图

另一种层次化分解是正交状态分解，它用来从不同的视角对同一对象状态进行建模。在这个方法中，状态图中高层次的状态可分解为两个或更多正交状态图。

两个正交状态图通过一条虚线隔开。当高层次的状态图处于复合状态时，它同时也处于第一个较低层次的正交状态图中的某一个子状态，也处于第二个较低层次的正交状态图中的某一子状态。

![](%E7%8A%B6%E6%80%81%E5%9B%BE-%E6%AD%A3%E4%BA%A4%E7%8A%B6%E6%80%81%E5%9B%BE.png)

#### 状态图的开发指导原则

以下所有列举的指导原则可用于开发扁平化状态图或层次化状态图，除非另有明确说明：

1. 当系统中正在**发生**某些事情时，状态名称必须反映可识别的情况或一段时间间隔。因此，状态名经常是形容词Idle、形容词短语ATM Idel、动名词Dispensing或动名词短语Waiting for PIN。同时，状态名不应该反映事件或动作，例如ATM Dispenses或Dispense Cash。
2. 在给定的状态图上，每一个状态要有唯一的名称。两个状态相同的名称将会产生歧义。理论上来说，在不同的复合状态之间，各自的子状态可以有相同的名称。然而这种情况会导致难以理解，因此最好避免该情况。
3. 必须要能从各个状态退出。由于状态图可能表示系统或对象的持续运行，因此一个状态图不必都有终止状态。
4. 在顺序状态图中，状态图在任一时刻只能处于一种状态中。两个状态不能同时被激活（例如：“等待PIN码”和“出钞”）。各个状态必须按顺序执行。
5. 不要混淆事件和动作。事件的名称表明某些事情刚刚发生（例如：“卡被插入”，“门被关闭”）或动作的结果，例如：“有效PIN码” 或 “第三次无效PIN码”。
6. 动作是一个命令。例如“出钞”、“开始烹饪”、“退卡”。
7. 动作是瞬间执行的。同一状态转换可能会关联多个动作。这些动作从概念上来说是同时执行，因此，不能假设这些动作执行的顺序。因此，这些动作之间必须不存在相互依赖的关系。如果存在依赖，则需要引入中间状态来解决。
8. 条件是布尔值。如果状态转换被标识为*事件 [ 条件 ]*, 那么只有事件发生时并且条件为真时才会发生该状态转换。条件在某一段时间间隔中值为真。“门关闭 [ 剩余时间不为0 ]”表示只有当门关闭并且剩余有限的时间时，该状态转换才会发生。如果门关闭但剩余时间为零，则该状态转换不会发生。
9. 动作和条件是可选的。只有必要时才会使用它们。

#### 从用例开发状态图

*要从用例来开发状态图，首先需要用例中的一个特定的**场景*，即用例中的一条特定路径。理想情况下：这个场景应该是贯穿整个用例的主序列，涉及参与者和系统之间交互的最常用序列。

现在考虑给定场景下外部事件的顺序。通常，一个外部环境中的输入事件会引起状态转换到一个新的状态，该状态转换的名称和状态中发生的事情相对应。如果一个动作和该状态转换相关联，则从一个状态转换为另一个状态时触发该动作。动作由用例中描述的系统对输入事件的响应来决定。

1. 先开发扁平化状态图，包括主场景中给出的事件顺序。状态图中的状态应该全部是外部可见的状态，即**参与者可以看到每个状态**。实际上，这些状态表示参与者直接或间接进行的操作的结果。
2. 要完成状态图，需要确定该状态图中**所有可能输入的外部事件**。通过考虑用例中**所有可替换路径**的描述来完成这个部分。
3. 在某些应用中，一个状态图可能会参与多个用例。在这种情况下，每个用例将对应一个部分的状态图。可以将这些部分的状态图集成起来从而形成一个完整的状态图。言下之意，在（至少某些）用例和其对应的状态图执行时将有优先级。**若要集成两个部分的状态图，则需要找到一个或多个公有状态**。一个公有状态可能是一个状态图的最后状态，并且是下一个状态图的开始状态。*然后，也存在其他情况。*集成的方法是通过公有状态集成部分的状态图，从而将第二个状态图的公有状态叠加到第一个状态图相同的状态上。上述方法可按需要重复使用，这依赖于有多少个部分状态图需要集成。
4. 有了*完成的扁平化状态图*，下一步就是**要开发层次化状态图**。实际上有两种方法开发层次化状态图。
	- 通过自顶向下的方法来确定主要的高层次状态，有时被称作“操作模式”。例如，在飞机控制状态图中，模式可能包括起飞、飞行中和着陆。每种模式包含一些状态，其中一些也可能是复合状态。这种方法经常使用在复杂的实时系统中，而这些实时系统经常都是与状态高度相关的。
	- 第二种方法是首先开发扁平化状态图，接着确定可以被聚合成复合状态的状态。

### 状态相关的动态交互建模

状态相关的动态交互建模能够处理对象间的交互是与状态相关的情况。状态相关的交互至少涉及一个与状态相关的控制对象，通过执行一个状态图，提供了全局的控制，并建立起它与其他对象间的交互序列。

*如果至少有一个对象是与状态相关的控制对象，那么这个交互就被定义为状态相关的，并且应当使用本章中所描述的**状态相关的动态交互建模**这个术语。

### 6.1 状态相关的动态交互建模中的步骤

建模者的目标是确定以下对象之间的交互：

1. 执行状态机的与状态相关的控制对象。
2. 对象，通常是软件边界对象，它们向控制对象发送事件。这些事件会导致控制对象的内部状态机的状态转换。
3. 提供动作和活动的对象，这些对象被控制对象由于状态转换而触发。
4. 其他参与实现用例的对象。

下面展示了状态相关的动态交互建模策略中的主要步骤。交互的序列需要反映用例中描述的交互的主序列。

1. *确定边界对象*。考虑那些接收输入的对象，输入由外部环境中的外部对象发送。
2. *确定状态相关的控制对象*。至少有一个执行状态图的控制对象。也可能需要其他对象。
3. *确定其他的软件对象*。这些对象是与控制对象或边界对象交互的软件对象。
4. *确定主序列场景中的对象交互*。把这一步和第5步一起执行，因为需要详细制定状态相关的控制对象和它执行的状态图之间的交互。
5. *确定状态图的执行*
6. *考虑可替换序列的场景*。针对由用例的可替换序列描述的常见，执行状态相关的动态分析。

