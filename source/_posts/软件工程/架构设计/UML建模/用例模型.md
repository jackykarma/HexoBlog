---
title: 用例模型
date: 2022-07-09 20:55:11
tags: 用例模型
categories: 软件工程
---

用例建模是一种描述系统的功能性需求的方法，它定义了一个或多个参与者与系统之间的交互序列。系统的输入和输出首先在用例建模中描述，而后在静态建模过程中进行细化。

![](%E6%88%AA%E5%B1%8F2022-07-09%2020.57.33.png)

需要注意的点：

1. 用例总是从参与者的输入开始，参与者可能是用户，也可能是外部系统。
2. 在确定用例的时候，记得将系统看做**黑盒**：思考系统最终会输出什么有价值的响应来呼应参与者的输入（系统输出结果），而不要去关注系统如何做的内部细节（系统内部实现过程）。要表述清楚系统要做什么（系统行为），但是不要描述怎么做（系统行为的内部实现细节）。

## 一、用例模型的作用

1. 在需求建模阶段，用来具体清晰的描述一个需求，或者说是参与者与系统之间的交互过程。
2. 在分析建模阶段，会基于用例模型来确定参与每个用例的类与对象、以及参与用例的各个对象之间的消息传递。
3. 在测试阶段，测试人员可以对每个用例进行详尽的测试，避免遗漏。

## 二、参与者

1. 参与者是系统之外的，不是系统的一部分。
2. 参与者是对一种用户类型的建模：单个客户是参与者的一个实例。参与者代表的是一类，一种类型；用户是一个个体。
3. 参与者不一定是人类用户。它可以是输入、输出设备，也可以是外部系统，或是计时器、传感器等等。主要类型有：
	- 人类参与者
	- 外部系统参与者：比如远程系统
	- 输入设备参与者、输入输出设备参与者：比如传感器
	- 计时器/定时器：比如定时触发事件
4. 参与者分主要参与者（启动用例的），和次要参与者（参与用例）
5. 参与者泛化：不同的参与者可能拥有一些公共的角色，但其他的角色却不相同。在此种情况下，这些参与者可以被泛化，使得他们角色中的公共部分能被捕获为泛化的参与者，而不同的部分则作为特化的参与者。例如“应急响应系统”，其中的两个参与者“监控传感器”参与者和“远程系统”参与者行为相似，都是监控远程传感器并向系统发送传感器数据和警报。这种相似的行为被建模为一个泛化的参与者，即“远程传感器”。
	![](%E6%88%AA%E5%B1%8F2022-07-09%2017.03.32.png)

7. 真正的参与者是谁：关注谁采集和录入input信息到“系统”；又是谁从用例中获取价值的。

## 三、标识用例

如何确定系统中的用例？

1. 从考虑参与者及其与系统间的交互开始，每个用例描述了参与者和系统之间的交互序列；系统的功能性需求通过用例来描述，用例构建了系统的功能规约；
2. 在开发用例时，最重要的是避免功能分解。在功能分解中，多个小的用例描述系统的单个小功能，而不是描述对参与者提供有用结果的事件序列。**中间结果就不算是对系统直接有用的结果**，它**可能算是系统的一个功能模块**。因此**区分功能与用例的概念是有必要的**。功能是否要拆解，是看情况的，关键是要避免过度功能分解。
	依据是：拆解后是否每个用例直接给参与者带来不同的有用结果。中间结果就不算是对系统直接有用的结果, 它或许是系统的一个模块，但未必适合作为一个独立的用例。但是如果拆解可以带有不同有用的结果，那么当然拆解更合理，因为拆解之后每个用例的描述更加具体清晰，用例关系也更加简单，结构更加清晰。
3. 避免将用户界面UI的具体显示方式纳入用例，比如使用何种类型显示、什么东西的控件，显示的位置与视觉效果，具体的交互方式（如：如何开启该UI界面），启用与禁用的条件等等，这些都是属于系统内部的具体实现。比如系统显示客户账号并提示客户交互类型。不要写成:系统显示客户设置界面，包含客户账号信息、交易类型选项。后者的写法明显是规定一个界面同时包含这两个信息，侧面上规定了UI的交互设计，这就涉及到了UI交互设计的具体实现方式了。

用例的主序列描述了参与者和系统之间最常见的交互序列。用例的主序列中也会存在分支来描述参与者和系统之间不那么频繁的交互。用例中的每个序列称作场景。一个用例通常描述了多个场景：一个主序列和多个可替换序列。

## 四、用例模型文档化规约

1. **用例名称**：每个用例都给予一个名字
2. **概述**：用例的简短描述，一般是一两句话
3. **依赖**：这个可选的部分描述了该用例是否依赖其他用例，即它是否包含include或扩展extend另一个用例。
4. **参与者**：该部分给用例中的参与者命名。总是有一个主要参与者来启动用例。另外可以有次要参与者也参与到用例中。
5. **前置条件**：从该用例的角度在用例开始时必须为真的一个或多个条件。例如，ATM机是空闲状态，屏幕显示“欢迎”消息。
6. **主序列描述**：用例的主题是对该用例主序列的叙述性描述，这是参与者和系统之间最经常的交互序列。该描述的形式是参与者的输入，接着是系统的响应。
7. **可替换序列描述**：主序列的可替换分支的叙述性描述。主序列可能有多个可替换分支。例如，如果客户的账户没有足够的资金，则显示抱歉并退出卡片。在给出可替换描述的同时，用例中可替换序列从主序列分支出来的这个步骤也被标识出来。
8. **非功能性需求**：非功能性需求的叙述性描述，例如性能和安全性需求。
9. **后置条件**：该用例终点处（从该用例的角度来看）总是为真的条件，如果遵循了主序列的话。例如，客户的资金已经被取出。
10. **未解决的问题**：在开发期间，有关用例的问题被记录下来，用于和用户进行讨论。

写用例模型时：要表述清楚系统要做什么（系统行为），但是不要描述怎么做（系统行为的内部实现细节）。

示例：

```js
用例名称：下单请求
概述：客户下单从在线购物系统中购买商品。客户的信用卡要验证有足够信用为所要购买的目录商品付款。
参与者：客户
前置条件：客户已选择一个或多个目录商品。
主序列：
	1. 客户提出订单请求和客户账户ID来为购买付款。
	2. 系统检索客户账户信息，包括该客户的信用卡详细信息。
	3. 系统针对购买价格检查客户的信用卡，并创建信用卡购买授权号码（如果检查通过）。
	4. 系统创建发货单，包含订单明细、客户ID和信用卡授权号。
	5. 系统确认批准购买，并向客户显示订单信息。
可替换序列：
	2.1. 如果客户没有账号，则系统为其创建一个账号。
	3.1. 如果客户的信用卡请求被拒绝，则系统提示客户输入不同的信用卡号码。客户可以输入一个不同的信用卡号码或者取消订单。
后置条件：系统为客户创建了发货单。
```

## 五、用例关系

用例关系主要用来简化复杂的用例序列或者用例复用。

### 5.1. 包含关系

如果一个用例（基本用例）包含另一个用例（包含用例）的功能，那么认为这两个用例之间存在包含关系。包含关系支持在用例模型中复用功能。包含关系一般用在：

1. 抽取2个及以上用例的共同交互序列来作为《包含用例》，以达到交互序列复用，从而解决交互序列冗长的问题，减少模型维护的工作量；
2. 其次，包含用例可以用来处理结构冗长的用例，包含用例用来表示低层次的交互序列，基用例表示高层次的交互序列，此时包含用例的目的并不是被其他用例所复用。将一个基用例(结构化冗长的用例)，过程化分成多个“小”用例来完成，那么这几个“小”用例，就相当于是这个结构化冗长用例的包含用例。是包含关系。也是交互序列的包含关系。(__用例过程复杂，分几个小的包含用例, 以此将原本复杂冗长的交互序列分成几个子交互序列__)

用途1示例：用例复用

![](%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-27%20%E4%B8%8A%E5%8D%888.16.14.png)

取现、查账、转账三个用例都包含“验证PIN码”的交互序列。三个不同分支选择，导致后半段的交互序列不同，但是仍然可以共用前半段的交互序列。

**包含用例“验证PIN码”**

```js
用例名称：验证PIN码
概述：系统验证客户PIN码
参与者：ATM客户
前置条件：ATM空闲，显示“欢迎”消息。
主序列：
1. 客户向读卡器插入ATM卡。
2. 如果系统识别了该卡，则读取卡号。
3. 系统提示客户输入PIN码。
4. 客户输入PIN码。
5. 系统检查该卡的有效期以及是否已经报告挂失。
6. 如果卡是有效的，则系统检查用户输入的PIN码是否和系统存储的卡PIN码匹配。
7. 如果PIN码数字匹配，则系统检查该ATM卡可访问哪些账户。
8. 系统显示客户账号并提示客户交易类型；取款、查询或转账。
```

**基用例“取款”**

```js
用例名称：取款
概述：客户从有效的银行账户提取特定数量的钱款。
参与者：ATM客户
依赖：包含“验证PIN码”用例。
前置条件：ATM机空闲，“显示”欢迎界面。
主序列：
1. 包含“验证PIN码”用例
2. 客户选择取款
3. (省去)
```

**基用例“查账”**

```js
用例名称：查账
...// 忽略
```

用途2示例：交互序列冗长的用例简化

![](%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-27%20%E4%B8%8A%E5%8D%888.42.11.png)

制造高容量部件的交互序列是接收部件的交互序列、在高容量工作站处理布局的交互序列、运输部件的交互序列三个的总和。

```js
用例名称：制造高容量部件
概述：生产高容量部件
参与者：产品经理、生产机器、分捡机器
依赖：包含“接收部件”、“高容量工作站处理部件”、“运输部件”用例
前置条件：生产环境准备好
主序列：
1. 包含“接收部件”
2. 包含“高容量工作站处理部件”
3. 包含“运输部件”
```

> > 包含关系并不是将多个类似的用例作为包含用例，提取一个抽象的基用例。因为这样基用例反而变得不可执行和抽象了，并且基用例交互序列与这些“包含用例”的交互序列的关系并非包含关系。更像是“父类”的关系。

### 5.2. 扩展用例

扩展关系用来对用例可能采取的可替换路径进行建模。如果一个用例有太多可替换的、可选的和异常的交互序列，那么它可能会变得非常复杂。

1. 一方面，基用例不依赖于扩展用例。
2. 另一方面，扩展用例依赖于基用例并只在基用例中引起它执行的条件为真时才执行。
3. 尽管一个扩展用例通常只扩展一个基用例，但它扩展一个以上的用例也是有可能的。一个基用例能够被多个扩展用例扩展。

扩展点：

1. 扩展点就是用来规定基用例中能被增加扩展的精确位置。一个扩展用例只可以在这些扩展点上扩展基用例。
2. 每个扩展点都被赋予了一个名称。扩展用例对于对于扩展点有一个插入片段，该片段在其基用例中扩展点的位置处插入。扩展关系可以是有条件的，这意味着可以定义一个条件，该条件必须为真时才调用扩展用例。这样，就可能在同一个扩展点上有多个扩展用例，但每个扩展用例都满足不同的条件。
3. 片段定义了在达到扩展点时所执行的行为片段。当用例的一个实例被执行并到达了基用例中的扩展点时，如果条件满足，则用例的执行将转移到扩展用例中的相应片段。在片段完成后，执行再转移回基用例。
4. 带着多个扩展用例的扩展点可用于对多个可替换情况建模，其中每个扩展用例规定了一个不同的可替换。要设计扩展条件，使得在任何给定的情况下只有一个条件为真，这样就只有一个扩展用例会被选择。
5. 扩展条件的值在用例的运行时执行期间被设置，这是因为在任何一次中只能选择一个扩展用例，而在另一次中则可以选择一个可替换的扩展用例。换句话说，扩展条件是在用例的运行时设定和更改的。
6. 虽然扩展用例可以在多个扩展点扩展一个用例，但这种方法只在扩展点扩展与扩展用例相等时才推荐。尤其是，在一个扩展用例中使用多个插入片段是有技巧的，因此也被认为是易于出错的。
7. 基用例中提供扩展点，多个扩展用例就是该扩展点的展开的交互序列。

是否可作为扩展点的判断：是否因为不同条件或参数设置而产生不同的交互序列。

扩展用例示例:（付款包含多种方式：现金、借记卡、信用卡）

![](%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-27%20%E4%B8%8A%E5%8D%8810.18.52.png)

当用户选择不同的付款方式时，就会导致后续系统的部分交互序列产生差异。

**基用例“顾客结账”**

```js
用例名称：顾客结账
概述：系统为顾客结账
参与者：顾客
前置条件：结账台空闲，显示“欢迎”消息。
主序列：
1. 顾客扫描所选的商品。
2. 系统显示商品名称、价格和累计总价。
3. 对每一项购买的商品，顾客重复步骤1和2.
4. 顾客选择付款方式
5. 系统提示现金付款、信用卡付款或借记卡付款。
6. <<付款>> 扩展点:付款行为可以拓展成三种方式
7. 系统屏幕显示“谢谢”
```

第6步《付款》是一个占位符，标识了有个何时的扩展用例在此执行。对于扩展用例“现金结账”，扩展条件是称作【现金付款】的选择条件。当条件为真时，该扩展用例会被执行。

**扩展用例“现金结账”**

```js
用例名称：现金结账
概述：顾客为购买的商品使用现金结账
参与者：顾客
依赖：扩展顾客结账
前置条件：顾客已经扫描了商品，但尚未付款。
插入片段的描述：
1. 顾客选择现金付款。
2. 系统提示顾客放入纸币或硬币现金。
3. 客户放入现金。
4. 系统计算找零
5. 系统显示应付款总额、现金付款额和找零。
6. 系统在收据上打印应付款总额，现金付款和找零。
```

**扩展用例“信用卡结账”**

```js
用例名称：信用卡结账
概述：顾客为购买的商品使用信用卡结账
参与者：顾客
依赖：扩展顾客结账
前置条件：顾客已经扫描了商品，但尚未付款。
插入片段的描述：
1. 顾客选择信用卡付款。
2. 系统提示顾客刷卡。
3. 顾客刷卡。
4. 系统读取卡的ID和有效期。
5. 系统将交易信息发送到授权中心，包含卡ID、有效期和支付金额。
6. 如果交易被批准，则授权中心返回肯定的确认信息。
7. 系统显示支付金额和确认信息。
8. 系统在收据上打印支付金额和确认信息。
// 如果扩展用例中还有条件分支，那么可以嵌套另一个扩展用例。
```

**扩展用例“借记卡结账”**

```js
用例名称：借记卡结账
...// 省略
```

#### 处理条件分支的建议

1. 不同条件将导致后面与与系统的交互序列不同。并且多个条件无主次序列之分。可以考虑使用：
	- **包含用例**：三种选择共用前面一段交互序列，都包含《验证PIN码》，用户选择不同的交易类型：取款、查询或转账，将会导致后续不同的交互序列。
	- **扩展用例**：付款用例中的选择付款付款方式，扩展点《付款》
	- 包含用例还是扩展用例选择：如果条件子分支序列占据整个交互序列的中间一部分，也就是头部交互序列、尾部交互序列对于所有条件来说都是相同，仅仅只有中间那段不同，那么可以使用扩展用例的方式。如果条件子分支序列，涉及系统整个后半段的所有交互序列，那么使用包含用例会更好。
2. 交互序列的分支之间存在主次之分：通常一个是正常运行时的交互序列（经常发生的交互序列），另外一个是异常的、错误的、或是不常发生的交互序列。
	- 主序列、可替换序列的方式处理。

### 5.3. 用例关系总结

1. 联系：都是从现有的用例中抽取出公共的那部分信息，作为一个单独的用例，然后通后过不同的方法来重用这个公共的用例，以减少模型维护的工作量。
2. 区别：
	- 扩展关系中基本用例的基本流执行时，扩展用例不一定执行，即扩展用例只有在基本用例满足某种条件的时候才会执行。包含关系中基本用例的基本流执行时，包含用例一定会执行。
	- 包含用例是基用例交互序列的一个确定的子序列，它是一定会被执行的；而扩展用例是基用例交互序列的一个不确定(条件确定)的子序列，也就是说在某个确定的条件下，对应条件为真的扩展用例就是基用例交互序列的一个确定的子序列。

要注意，不宜采用对应于独立功能(例如出钞、打印回执和退卡)的小的包含用例。这些功能太小了，把他们从用例中分离出来会导致功能分解，使用例碎片化。这些碎片化用例的用例描述可能每个只有一句话而不是对交互序列的描述，这就会导致一个过度复杂和难以理解的用例模型。

## 六、用例包

对于大型系统，不得不处理用例模型中的大量用例经常是很难操作的。解决这种增大问题的一个好的方法是引用例包，**将相关的用例分组到一起**。这样，用例包就能表示那些描述系统的主要功能子集的高层子需求。

![](%E6%88%AA%E5%B1%8F2022-07-09%2020.09.50.png)

## 七、活动图

1. 活动图是一种描述控制流和活动中序列的UML图。活动图显示了活动序列、决策结点和循环，甚至还有并发活动。活动图在工作流建模中被广泛使用，例如，在面向服务的应用中。
2. **用例模型也能使用活动图来描述**。然而，活动图能力的一个子集就足以描述用例。特别地，对于用例没有必要对并发活动进行建模。
3. 活动图可用来表示用例的**顺序步骤**，包括主序列和所有的可替换序列。

活动图使用活动结点、决策节点、连接顺序活动点的弧和循环来描绘用例。

1. 活动结点：用来描绘用例描述中的一个或多个步骤；活动节点可用来表示该用例的一个或多个顺序步骤。高层活动结点可用来表示一个用例，该用例稍后可被分解成一个独立的活动图。活动图也可用来描绘用例中的顺序。
2. 决策结点：用来描绘基于决策结果可替换虚了会从主序列中分支出来的情况。取决于用例，可替换序列可以重新合并到主序列中，例如，循环回到之前的活动结点或者之后重新合并到主序列中。

示例：高层次的活动节点用来表示一个用例“下订单请求”；然后该用例被分解成一个独立的活动图。低层次的每个活动节点Action表示“下订单请求”中的一个或多个步骤，在分支条件也就是决策结点(Decision)描述可替换序列中的步骤，比如账户存在与账户不存在；信用卡有效与无效。

![](%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-27%20%E4%B8%8B%E5%8D%889.16.30.png)
