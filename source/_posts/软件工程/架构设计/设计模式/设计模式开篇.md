---
title: 设计模式开篇
date: 2022-03-26 13:56:03
tags: 设计模式
categories: 设计模式
---

参考资料：

[Java设计模式浅谈](http://www.cnblogs.com/chenpi/category/780173.html)

## 一、什么是设计模式？

> > 个人理解：设计模式就是解决特定类型问题的方法或套路。

ChristopherAlexander说过：“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。

设计模式是对用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。一个模式具备四个基本要素：

1. 模式名称：一个助记名，它用一两个词来描述模式的问题、解决方案和效果。
2. 问题：描述了应该在何时使用模式。它解释了设计问题和问题存在的前因后果。它可能描述了特定的设计问题（如怎样用对象表示算法等）也可能描述了导致不灵活设计的类或对象结构。有时候，问题部分会包括使用模式必须满足的一系列先决条件。
3. 解决方案：描述了设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。
4. 效果：描述了模式应用的效果及使用模式应权衡的问题。尽管我们描述设计决策时并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。

出发点的不同会产生对什么是模式和什么不是模式的理解不同。一个人的模式对另一个人来说可能只是基本构造部件。大的解决方案中包含多个小的解决方案。所以白话讲：设计模式就是解决一类问题的套路。

### 1.1、设计模式与框架的区别

1. 设计模式比框架更抽象：框架能够用代码表示，而设计模式只有其实例才能表示为代码。框架的威力在于它们能够使用程序设计语言写出来，它们不仅能被学习，也能被直接执行和复用。设计模式还解释了它的意图、权衡和设计效果。
2. 设计模式是比框架更小的体系结构元素：一个典型的框架framework可能包括了多个设计模式的运用，而反之绝非如此；
3. 框架比设计模式更加特例化：框架总是针对一个特定的应用领域，通常描述为某个领域的framework框架，比如Android平台框架。一个图形编辑框架可能被用于一个工厂模拟，但它不会被错认为是一个模拟框架。而设计模式几乎能被用于任何应用。

## 二、设计模式的学习方法

1. 学习目标：
	- 学习如何利用其他开发人员的经验与智慧，他们遭遇过相同的问题，也顺利地解决过这些问题。
	- 模式是如何运作的
2. 设计模式的用途与优点：以往是代码复用，现在是经验复用。
3. 使用模式的最好方式：把模式理解记忆于大脑中，然后在你的设计和已有的应用中，寻找何处可以使用他们。

## 三、模式的描述方法

光用UML描述某种设计模式是不够的，它们只是简单将设计过程的结果记录为类和对象之间的关系。为了达到设计复用，必须同时记录：设计产生的决定过程、选择过程和权衡过程。

描述设计模式的统一格式：

1. 模式名和分类：模式名简洁地描述了模式的本质；模式的分类反映了方案类型
2. 意图：回答如下问题：该设计模式是做什么的？它的基本原理和意图是什么？它解决的是什么样的特定设计问题？
3. 别名：模式的其他名称
4. 动机：说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定场景
5. 适用性：什么情况下可以使用该设计模式？该模式可用来改进哪些不良设计？你怎样识别这些情况？
6. 结构：采用基于对象建模技术OMT的表示法对模式中的类进行图形描述；同时采用交互图说明对象之间的请求序列和协作关系。
7. 参与者：指设计模式中的类和、或对象以及它们各自的职责
8. 协作：模式的参与者怎样协作以实现它们的职责
9. 效果：模式怎样支持它的目标？使用模式的效果和所需做的权衡取舍？系统结构的哪些方面可以独立改变？
10. 实现：实现模式时需要知道的一些提示、技术要点及应避免的缺陷，以及是否存在某些特定于实现语言的问题。
11. 代码示例：如何实现模式的代码片段
12. 已知应用：实际系统中发现的模式的例子，每个模式至少包括了两个不同领域的实例。
13. 相关模式：与此模式紧密相关的模式有哪些？其间重要的不同之处是什么？这个模式与哪些其他模式一起使用？

## 四、模式的分类

常用模式根据目的分类：

1. 创建型模式Creational
2. 结构型模式Structural
3. 行为型模式Behaviral

![](%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-07-09%20%E4%B8%8B%E5%8D%885.48.38.png)


## 五、设计模式怎样解决设计问题

设计模式采用多种方法解决面向对象设计者经常碰到的问题。这里给出几个问题以及使用设计模式解决他们的方法。

### 5.1. 寻找合适的对象

面向对象Orientation-Object程序由对象组成，对象包括数据和对数据进行操作的过程，过程通常称为方法Method或操作。对象在接收到客户端的请求(或消息)后，执行相应的Method操作。客户请求是使对象执行操作的唯一方法，如A.f()可以翻译为”向对象A发送f请求/消息”; 操作又是对象改变内部数据的唯一方法，所以由于此限制，对象的数据通常是被封装的，它不能被直接访问。面向对象设计最困难的部分是将系统分解成对象集合，考虑的因素包括：

- 封装性
- 对象的粒度
- 依赖关系
- 灵活性
- 性能
- 演化
- 复用等

基本设计方法：**写一个问题描述，挑出名词和动词**，进而创建相应的类和操作；或者可以关注于系统的**协作和职责关系**；或者可以**对现实世界建模**，再将分析时发现的对象转化至设计中。严格反映当前现实世界的模型并不能产生也能反映将来世界的系统。**设计中的抽象对于产生灵活的设计是至关重要的**。

### 5.2. 决定对象的粒度

对象在大小和数目上变化极大，那么如何决定一个对象应该是什么呢？设计模式很好的讲述了这个问题。Facade外观模式描述了怎样用对象表示完整的子系统，FlyWeight模式描述了如何支持大量的最小粒度的对象。

### 5.3. 指定对象接口

1. 型构Signature：对象声明的每一个方法指定方法名、作为参数的对象和返回值的整体被称为型构或方法的签名。
2. 对象的接口Interface：对象操作所定义的所有操作型构的集合。对象接口描述了该对象所能接受的全部请求的集合。
3. 类型Type：用来标识特定接口的一个名字。如果一个对象接受“Window”接口所定义的所有操作请求，那么我们就说该对象具有“Window”类型，并且不同的对象可以共享同一个类型。

接口可以包含其他接口作为子集。当一个类型的接口包含另一个类型的接口，就说他是另一个类型的子类型subtype，另一个类型称之为超类型supertype，子类型继承了它的超类型的接口。

面对对象系统中，接口是基本的组成部分。对象只有通过他们的接口才能与外部交流，如果不通过对象的接口就无法知道对象的任何事物，也无法请求对象做任何事情。对象接口与其功能是分离的，不同对象可以对请求做不同的实现，也就是说，两个有相同接口的对象可以由完全不同的实现。

动态绑定：指发送的请求直到运行时才受你的具体的实现的约束，因为，在知道任何有正确接口的对象都讲接受此请求时，你可以写一个一般的程序，它期待着那些具有该特定接口的对象。动态绑定允许你再运行时刻彼此替换有相同接口的对象，这种可替换性就称为多态性polymorphism。多态简化了客户端的定义，使得对象间彼此独立，并可以在运行时动态改变他们相互的关系。

### 5.4. 描述对象的实现

抽象类abstract class：主要目的是为子类们定义公共的接口，一个抽象类将把它的部分或全部操作的实现延迟到子类中。非抽象类叫具体类Concrete class。重定义/覆盖override：类能够重定义override父类定义的操作，重定义使得子类能够接管父类对请求的处理操作。

1. 类继承与接口继承的比较：理解对象的类class与对象的类型type之间的差别非常重要。一个对象的类定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的实现。但是对象的类型type只与它的接口有关，接口即对象能响应的请求的集合，它不代表实现。一个对象可以有多个类型type，不同类的对象也可以有相同的类型。类继承是根据一个对象的实现定义了另外一个对象的实现，简而言之，继承是代码和表示的共享机制。然后，接口继承或子类型化描述了一个对象什么时候能被用来替代另一个对象，因为他们的接口或类型相同，知识实现不同而已，只要type相同就可以对象互换。比如A,B对象都是实现超类abstract class C，或者interface C，尽管A，B对象实现的接口方法不同，但是扔可以互换，因为A,B都是属于C类型type的。接口继承(interface继承或abstract抽象类继承)与实现继承是要分别对待的。
2. 对接口编程，而不是对实现编程：类继承是一个通过复用父类功能而扩展应用功能的基本机制，它允许你根据旧对象快速定义新对象。它允许你从已存在的类中继承所需要的绝大部分功能，从而几乎无需任何代价就可以获得新的实现。然而，实现复用只是成功了一半，继承所拥有的定义具有相同接口的对象族的能力也是很重要的(通过可以从抽象类继承)，因为多态依赖于这种能力，它可以在运行时绑定正确的对象，并发出请求。只根据抽象类中定义的接口来操纵对象的好处：
	- 客户无需知道他们使用对象的特定类型，只需对象有客户所期望的接口；
	- 客户无须知道他们使用的对象是用什么类型来实现的，他们只须知道定义接口的抽象类；
3. 当你不得不在系统的某个地方实例化具体的类，即指定一个特定的实现时，创建型模式可以帮助你，通过**抽象对象的创建过程**，这些模式提供不同方式在实例化时建立接口和实现的透明连接。创建型模式确保你的系统式采用针对接口的方式书写，而不是针对实现而书写的。

### 5.5. 运用复用机制的方法：几种复用技术

1. 继承与组合的比较：继承属于白箱复用white-box reuse，因为在继承方式中，父类的内部细节对子类可见。对象组合属于黑箱复用black-box reuse，因为对象的内部细节不可见。继承与组合各有千秋。类继承是在编译时刻静态定义的的，且可直接使用，因为程序设计支持类继承。类继承可以较方便的改变被复用的实现。类继承也有不足之处，首先因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现。更糟的是，父类通常至少定义了部分子类的具体表示。因为继承对子类揭示了父类的实现细节，所以继承常被认为“破坏了封装性”。子类中的实现与它的父类有如此紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。其次，实现上的依赖问题，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换，此种依赖限制的灵活性并最终限制了复用。一个可用的方法就是只继承抽象类，因为抽象类通常提供较少的实现。
2. 对象组合：通过获得对其他对象的引用而在运行时刻动态定义的。组合要求对象遵守彼此的接口约定，进而要求更仔细的定义接口；对象只能通过接口访问，所以我们不破坏封装性；只要类型type一致，运行时刻还可以用一个对象来替换另一个对象；因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系；可以优先使用对象组合有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物；系统的运行依赖于对象间的关系，而不是被定义在某个类中。
3. 优先使用对象组合，而不是继承：
4. 委托delegation：是一种组合方法，它使组合具有与继承同样的服用能力。在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给它的代理者delegate。接受请求的对象将自己传给委托者/代理人，使被委托的操作可以引用接受请求的对象。状态模式、策略模式、Visitor模式、代理模式都采用了委托。
5. 继承和参数化类型的比较：另一种服用技术就是参数化类型，也就是类属generic或模板templates。它允许你在定义一个类型时并不指定该类型所用到的其他所有类型。未经指定的类型在使用时以参数形式提供。

总结：对象组合技术允许你在运行时改变被组合的行为，但是它存在**间接性，比较低效**。继承允许你提供操作的缺省实现，并通过子类重定义这些操作。参数化类型允许你改变类所用到的类型。但是继承和参数化类型都不能在运行时刻改变。

### 5.6. 关联运行时刻和编译时刻的结构

一个面向对象程序运行时刻的结构通常与它的代码结构相差较大。代码结构在编译时候就被确定下来了，它由继承关系固定的类组成。而程序的运行时刻结构是由快速变化的通信对象网络组成。事实上两个结构是彼此独立的，试图由一个去理解另一个就好像试图从静态的动、植物分类去理解活生生的生态系统的动态性。反之亦然。

对象聚合Aggergation：聚合意味着一个对象包含另一个对象或是另一个对象的一部分，聚合意味着对象和其所有者具有相同的生命周期。

对象相识Acquaintancen：相识意味着一个对象仅仅知道另一个对象，有时相识也被称为“关联”或“引用”关系，相识的对象可能请求彼此的操作，但是它们不为对方负责。相识是一种比聚合要弱的关系，它只标识了对象间较松散的耦合关系。

![](%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-07-09%20%E4%B8%8B%E5%8D%886.49.01.png)

上图中，普通的箭头线表示相识，尾部带有菱形的箭头线表示聚合。聚合和相识很容易混淆，是聚合还是相识是由你的意图而不是由显示的语言机制决定的。

对象和它们的类型之间的关系必须要更加仔细的设计，因为它们决定了运行时刻程序结构的好坏。组合模式和装饰者模式对于构造复杂的运行时结构特别有用。总之，只有理解了模式，你才能清楚代码中的运行时刻结构。

### 5.7. 设计应支持变化

获得最大限度的复用的关键置于对新需求和已有需求发生变化时的预见性，要求你的系统设计要能够相应地改进。为了设计适应这种变化、且具有健壮性的系统，你必须考虑系统在它的生命周期内会发生怎样的变化。一个不考虑系统变化的设计在将来就有可能需要重新设计。这些变化可能是类的重新定义和实现，修改客户和重新测试。重新设计会影响软件系统的许多方面，并且未曾料到的变化总是代价巨大的。

设计模式可以确保系统能以特定方式变化，从而帮助你避免重新设计系统。每一个设计模式允许系统结构的**某个方面的变化独立于其他方面(封装变化)**，这样产生的系统对于某一种特殊变化将更健壮。导致重新设计的一半原因如下：

1. 通过显示地指定一个类来创建对象：在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来的变化更负责。要避免此种情况，应该间接地创建对象。设计模式：抽象工厂、工厂方法、原型、单例。
2. 对特殊操作的依赖：当你请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免把请求代码写死，你将可以在编译时刻或运行时刻很方便地改变响应请求的方法。设计模式：责任链模式、命令模式。
3. 对硬件和软件平台的依赖：外部的操作系统接口和应用程序接口在不同的软硬件平台是不同的。依赖于特定平台的软件将很难移植到其他平台上，甚至都很难跟上本地平台的更新。所以设计系统时限制其平台相关性就很重要了。设计模式：抽象工厂、桥接模式。
4. 对对象表示或实现的依赖：知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。设计模式：抽象工厂、桥接、Memento、代理模式
5. 算法依赖：算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。设计模式：Builder构建模式、迭代器模式、策略模式、模板方法、Visitor模式
6. 紧耦合：紧耦合的类很难独立地被复用，因为他们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习、移植和维护的密集体。设计模式：抽象工厂、命名模式、外观模式、Mediator、观察者模式、责任链模式
7. 通过生成子类来扩充功能：通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销。定义子类还需要对父类有深入的了解。你可以定义一个子类，且将它的实例和已存在的实例进行组合来引入定制功能。设计模式：桥接模式、责任链模式、组合、装饰者、观察者、策略
8. 不能方便地对类进行修改：有时你不得不改变一个难以修改的类。也许你需要源代码而又没有，或者可能对类的任何改变会要求修改许多已存在的其他子类。设计模式提供在这些情况下对类进行修改的方法。设计模式：适配器模式、装饰者模式、Visitor模式

## 六、23种常用设计模式简单介绍

### 6.1. 对象创建型模式：对象的创建或类创建的方式

1. Abstrac Factory 抽象工厂：（类）提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
2. Factory Method 工厂方法：（对象）定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法使一个类的实例化延迟到其子类。
3. Builder 构建型模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。类的参数化数量不一致，很多的时候考虑使用Builder模式
4. Prototype 原型模型：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
5. Singleton 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

### 6.2. 结构型模式：类或对象的组装、组合方式

1. Adapter 适配器模式：类适配器和对象适配器。将一个类的接口转换成客户希望的另外一组接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
2. Decorator 装饰者模式：动态地给一个对象添加一些额外的职责：行为和属性。就扩展功能而言，Decorator模式比生成子类(继承行为)方式更为灵活。
3. Facade 外观模式：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用，组件的升级更好维护。
4. Bridge 桥接模式：将抽象部分与它的实现分离，使他们都可以独立地变化。
5. Proxy 代理模式：控制访问，为其他对象提供一个代理以控制对这个对象的访问。
6. Composite 组合模式：将对象组合成树形结构以表示“部分-整体” has-a的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性。
7. FlyWeight 轻量模式：运用共享技术有效地支持大量细粒度的对象，减少内存占用。

### 6.3. 行为型模式：一组对象怎样协作完成单个对象所无法完成的任务，算法和控制流相关的描述

1. Command 命令模式：将一个请求(消息-方法-方法在Java中无法传递(C中函数指针))封装为一个对象(类型-\>转型-\>Java动态绑定-\>灵活适配)，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持撤销、可取消的操作。
2. Template Method 模板方法：定义一个操作中的算法的骨架(特征表现，算法流程大体架构固定),而将其中的一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的整体骨架即可重新定义该算法的某些特定步骤。
3. Strategy 策略模式：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。
4. Observer 观察者模式：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖它的对象都得到通知并自动刷新。
5. State 状态模式：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。
6. Iterator 迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露该对象的内部表示。
7. Chain of Responsibility 责任链模式：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连城一条链，并沿着这条链传递该请求，直到有一个对象处理它。
8. Mediator 中介者模式：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
9. Memento 备忘录/纪念品模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。
10. Interpreter 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
12. Visitor 访问者模式：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

## 七、设计模式如何选如何选择、权衡(了解模式的边界、优缺点)

通过对下列6条因素的了解和考虑来权衡，选择最优的模式或模式组合进行设计。

1. 考虑设计模式是怎样解决设计问题的
2. 浏览模式的意图部分
3. 研究模式怎样互相关联，模式之间的关系
4. 研究模式目的相似的模式
5. 检查重新设计的原因
6. 考虑你的设计中哪些是可变的，哪些是不变的

设计模式的边界：引入设计模式带来了灵活性、可复用和维护、可扩展性；同时因为引入间接层次获得灵活和可变性的同时，你也使设计变得更复杂或牺牲了一定的性能。一个设计模式只有当它提供的灵活性是真正需要的时候，才有必要使用。当衡量一个模式的得失时，它的效果部分是最能够提供帮助的。

### 7.1. 如何使用设计模式

一旦选定了设计模式或设计模式组合，你该如何正确使用它们呢？如下给出了有效的循序渐进的方法：

1. 大致浏览一遍选定的模式：特别注意其边界(适用性部分)和效果部分，也就是了解其优缺点，确定它适合你的问题
2. 回头研究结构部分、参与者部分和协作部分：确保你理解这个模式的类和对象以及它们是怎样关联和交互的；
3. 看代码示例部分，看看这个模式代码形式的具体例子：研究代码将有助于你实现模式；
4. 选择模式参与者的名字，使它们在应用上下文中有意义：设计模式参与者的名字通常过于抽象而不会直接出现在应用中。然而，将参与者的名字和应用中出现的名字合并起来是很有用的。这会帮助你在实现中更显示的体现出模式来。例如，如果你在文本组合算法中适用了Strategy模式，那么你可能有名为SimpleLayoutStrategy或TextLayoutStrategy这样的类。
5. 定义类：声明它们的接口，建立它们的继承关系，定义代表数据和对象引用的实例变量。识别模式会影响到你的应用中存在的类，作出相应的修改。
6. 定义模式中专用于应用的操作名称：这里再一次体现出，名字一般依赖于应用。使用与每一个操作相关联的责任和协作作为指导。还有，你的名字一定要一致。例如，可以使用“Create”前缀统一标记Factory方法。
7. 实现执行模式中责任和协作的操作：实现部分提供线索指导你进行实现，代码实例部分的例子也能提供帮助。










